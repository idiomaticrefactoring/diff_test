diff -uarN codegen/algorithms.py RefactoringIdiomsOutputdir/algorithms.py
--- codegen/algorithms.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/algorithms.py	2022-11-24 08:58:21.000000000 +0800
@@ -58,20 +58,16 @@
     """
 
     if delta is None:
-        delta = Dummy()
-        Wrapper = Scope
-        name_d = 'delta'
+        delta , Wrapper , name_d  = Dummy(), Scope, 'delta'
     else:
-        Wrapper = lambda x: x
-        name_d = delta.name
+        Wrapper , name_d  = lambda x: x, delta.name
 
     delta_expr = -expr/expr.diff(wrt)
     whl_bdy = [Assignment(delta, delta_expr), AddAugmentedAssignment(wrt, delta)]
     if debug:
         prnt = Print([wrt, delta], r"{}=%12.5g {}=%12.5g\n".format(wrt.name, name_d))
         whl_bdy = [whl_bdy[0], prnt] + whl_bdy[1:]
-    req = Gt(Abs(delta), atol)
-    declars = [Declaration(Variable(delta, type=real, value=oo))]
+    req , declars  = Gt(Abs(delta), atol), [Declaration(Variable(delta, type=real, value=oo))]
     if itermax is not None:
         counter = counter or Dummy(integer=True)
         v_counter = Variable.deduced(counter, 0)
@@ -146,6 +142,5 @@
     not_in_params = expr.free_symbols.difference({_symbol_of(p) for p in params})
     if not_in_params:
         raise ValueError("Missing symbols in params: %s" % ', '.join(map(str, not_in_params)))
-    declars = tuple(Variable(p, real) for p in params)
-    body = CodeBlock(algo, Return(wrt))
+    declars , body  = tuple((Variable(p, real) for p in params)), CodeBlock(algo, Return(wrt))
     return FunctionDefinition(real, func_name, declars, body, attrs=attrs)
diff -uarN codegen/approximations.py RefactoringIdiomsOutputdir/approximations.py
--- codegen/approximations.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/approximations.py	2022-11-24 08:58:22.000000000 +0800
@@ -53,8 +53,7 @@
 
     def __init__(self, bounds, reltol, **kwargs):
         super().__init__(**kwargs)
-        self.bounds = bounds
-        self.reltol = reltol
+        self.bounds , self.reltol  = bounds, reltol
 
     def __call__(self, expr):
         return expr.factor().replace(self.query, lambda arg: self.value(arg))
@@ -84,17 +83,13 @@
                 return add
 
         if all(term.is_number or term in self.bounds for term in add.args):
-            bounds = [(term, term) if term.is_number else self.bounds[term] for term in add.args]
-            largest_abs_guarantee = 0
+            bounds , largest_abs_guarantee  = [(term, term) if term.is_number else self.bounds[term] for term in add.args], 0
             for lo, hi in bounds:
                 if lo <= 0 <= hi:
                     continue
                 largest_abs_guarantee = max(largest_abs_guarantee,
                                             min(abs(lo), abs(hi)))
-            new_terms = []
-            for term, (lo, hi) in zip(add.args, bounds):
-                if max(abs(lo), abs(hi)) >= largest_abs_guarantee*self.reltol:
-                    new_terms.append(term)
+            new_terms = [term for (term, (lo, hi)) in zip(add.args, bounds) if max(abs(lo), abs(hi)) >= largest_abs_guarantee * self.reltol]
             return add.func(*new_terms)
         else:
             return add
@@ -140,9 +135,7 @@
     """
     def __init__(self, bounds, reltol, max_order=4, n_point_checks=4, **kwargs):
         super().__init__(**kwargs)
-        self.bounds = bounds
-        self.reltol = reltol
-        self.max_order = max_order
+        self.bounds , self.reltol , self.max_order  = bounds, reltol, max_order
         if n_point_checks % 2 == 1:
             raise ValueError("Checking the solution at expansion point is not helpful")
         self.n_point_checks = n_point_checks
@@ -163,15 +156,12 @@
         if symb not in self.bounds:
             return fexpr
         lo, hi = self.bounds[symb]
-        x0 = (lo + hi)/2
-        cheapest = None
+        x0 , cheapest  = (lo + hi) / 2, None
         for n in range(self.max_order+1, 0, -1):
-            fseri = fexpr.series(symb, x0=x0, n=n).removeO()
-            n_ok = True
+            fseri , n_ok  = fexpr.series(symb, x0=x0, n=n).removeO(), True
             for idx in range(self.n_point_checks):
                 x = lo + idx*(hi - lo)/(self.n_point_checks - 1)
-                val = fseri.xreplace({symb: x})
-                ref = fexpr.xreplace({symb: x})
+                val , ref  = fseri.xreplace({symb: x}), fexpr.xreplace({symb: x})
                 if abs((1 - val/ref).evalf(self._prec)) > self.reltol:
                     n_ok = False
                     break
diff -uarN codegen/ast.py RefactoringIdiomsOutputdir/ast.py
--- codegen/ast.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/ast.py	2022-11-24 08:58:21.000000000 +0800
@@ -200,7 +200,7 @@
     def _construct(cls, attr, arg):
         """ Construct an attribute value from argument passed to ``__new__()``. """
         # arg may be ``NoneToken()``, so comparation is done using == instead of ``is`` operator
-        if arg == None:
+        if not arg:
             return cls.defaults.get(attr, none)
         else:
             if isinstance(arg, Dummy):  # SymPy's replace uses Dummy instances
@@ -290,11 +290,8 @@
 
     def _sympyrepr(self, printer, *args, joiner=', ', **kwargs):
         from sympy.printing.printer import printer_context
-        exclude = kwargs.get('exclude', ())
-        values = [getattr(self, k) for k in self._fields]
-        indent_level = printer._context.get('indent_level', 0)
+        exclude , values , indent_level , arg_reprs  = kwargs.get('exclude', ()), [getattr(self, k) for k in self._fields], printer._context.get('indent_level', 0), []
 
-        arg_reprs = []
 
         for i, (attr, value) in enumerate(zip(self._fields, values)):
             if attr in exclude:
@@ -410,8 +407,7 @@
     """
 
     def __new__(cls, lhs, rhs):
-        lhs = _sympify(lhs)
-        rhs = _sympify(rhs)
+        lhs , rhs  = _sympify(lhs), _sympify(rhs)
 
         cls._check_args(lhs, rhs)
 
@@ -445,8 +441,7 @@
         # Indexed types implement shape, but don't define it until later. This
         # causes issues in assignment validation. For now, matrices are defined
         # as anything with a shape that is not an Indexed
-        lhs_is_mat = hasattr(lhs, 'shape') and not isinstance(lhs, Indexed)
-        rhs_is_mat = hasattr(rhs, 'shape') and not isinstance(rhs, Indexed)
+        lhs_is_mat , rhs_is_mat  = hasattr(lhs, 'shape') and (not isinstance(lhs, Indexed)), hasattr(rhs, 'shape') and (not isinstance(rhs, Indexed))
 
         # If lhs and rhs have same structure, then this assignment is ok
         if lhs_is_mat:
@@ -630,8 +625,7 @@
 
     """
     def __new__(cls, *args):
-        left_hand_sides = []
-        right_hand_sides = []
+        left_hand_sides , right_hand_sides  = [], []
         for i in args:
             if isinstance(i, Assignment):
                 lhs, rhs = i.args
@@ -640,8 +634,7 @@
 
         obj = CodegenAST.__new__(cls, *args)
 
-        obj.left_hand_sides = Tuple(*left_hand_sides)
-        obj.right_hand_sides = Tuple(*right_hand_sides)
+        obj.left_hand_sides , obj.right_hand_sides  = Tuple(*left_hand_sides), Tuple(*right_hand_sides)
         return obj
 
     def __iter__(self):
@@ -722,11 +715,10 @@
         # enumerate keeps nodes in the same order they are already in if
         # possible. It will also allow us to handle duplicate assignments to
         # the same variable when those are implemented.
-        A = list(enumerate(assignments))
+        A , var_map  = list(enumerate(assignments)), defaultdict(list)
 
         # var_map = {variable: [nodes for which this variable is assigned to]}
         # like {x: [(1, x := y + z), (4, x := 2 * w)], ...}
-        var_map = defaultdict(list)
         for node in A:
             i, a = node
             var_map[a.lhs].append(node)
@@ -802,9 +794,7 @@
             symbols=symbols, optimizations=optimizations, postprocess=postprocess,
             order=order)
 
-        new_block = [Assignment(var, expr) for var, expr in
-            zip(self.left_hand_sides, reduced_exprs)]
-        new_assignments = [Assignment(var, expr) for var, expr in replacements]
+        new_block , new_assignments  = [Assignment(var, expr) for (var, expr) in zip(self.left_hand_sides, reduced_exprs)], [Assignment(var, expr) for (var, expr) in replacements]
         return self.topological_sort(new_assignments + new_block)
 
 
@@ -1115,10 +1105,8 @@
         0.123456789012345649
 
         """
-        val = sympify(value)
+        val , ten , exp10  = sympify(value), Integer(10), getattr(self, 'decimal_dig', None)
 
-        ten = Integer(10)
-        exp10 = getattr(self, 'decimal_dig', None)
 
         if rtol is None:
             rtol = 1e-15 if exp10 is None else 2.0*ten**(-exp10)
@@ -1137,8 +1125,7 @@
 
     def _latex(self, printer):
         from sympy.printing.latex import latex_escape
-        type_name = latex_escape(self.__class__.__name__)
-        name = latex_escape(self.name.text)
+        type_name , name  = latex_escape(self.__class__.__name__), latex_escape(self.name.text)
         return r"\text{{{}}}\left(\texttt{{{}}}\right)".format(type_name, name)
 
 
diff -uarN codegen/cutils.py RefactoringIdiomsOutputdir/cutils.py
--- codegen/cutils.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/cutils.py	2022-11-24 08:58:21.000000000 +0800
@@ -3,6 +3,5 @@
 def render_as_source_file(content, Printer=C99CodePrinter, settings=None):
     """ Renders a C source file (with required #include statements) """
     printer = Printer(settings or {})
-    code_str = printer.doprint(content)
-    includes = '\n'.join(['#include <%s>' % h for h in printer.headers])
+    code_str , includes  = printer.doprint(content), '\n'.join(['#include <%s>' % h for h in printer.headers])
     return includes + '\n\n' + code_str
diff -uarN codegen/fnodes.py RefactoringIdiomsOutputdir/fnodes.py
--- codegen/fnodes.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/fnodes.py	2022-11-24 08:58:21.000000000 +0800
@@ -281,13 +281,13 @@
         if len(args) == 2:
             low, high = args
             return Basic.__new__(cls, sympify(low), sympify(high))
-        elif len(args) == 0 or (len(args) == 1 and args[0] in (':', None)):
+        elif not len(args) or (len(args) == 1 and args[0] in (':', None)):
             return Basic.__new__(cls)  # assumed shape
         else:
             raise ValueError("Expected 0 or 2 args (or one argument == None or ':')")
 
     def _sympystr(self, printer):
-        if len(self.args) == 0:
+        if not len(self.args):
             return ':'
         return ":".join(str(arg) for arg in self.args)
 
@@ -324,7 +324,7 @@
             parameters.append(Extent(*arg))
         else:
             parameters.append(sympify(arg))
-    if len(args) == 0:
+    if not len(args):
         raise ValueError("Need at least one dimension")
     return Attribute('dimension', parameters)
 
diff -uarN codegen/futils.py RefactoringIdiomsOutputdir/futils.py
--- codegen/futils.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/futils.py	2022-11-24 08:58:21.000000000 +0800
@@ -26,14 +26,11 @@
 
     """
     printer_settings = printer_settings or {'standard': 2003, 'source_format': 'free'}
-    printer = FCodePrinter(printer_settings)
-    dummy = Dummy()
+    printer , dummy  = FCodePrinter(printer_settings), Dummy()
     if isinstance(definitions, Module):
         raise ValueError("This function expects to construct a module on its own.")
     mod = Module(name, chain(declarations, [dummy]), definitions)
-    fstr = printer.doprint(mod)
-    module_use_str = '   %s\n' % '   \n'.join(['use %s, only: %s' % (k, ', '.join(v)) for
-                                                k, v in printer.module_uses.items()])
+    fstr , module_use_str  = printer.doprint(mod), '   %s\n' % '   \n'.join(['use %s, only: %s' % (k, ', '.join(v)) for (k, v) in printer.module_uses.items()])
     module_use_str += '   implicit none\n'
     module_use_str += '   private\n'
     module_use_str += '   public %s\n' % ', '.join([str(node.name) for node in definitions if getattr(node, 'name', None)])
diff -uarN codegen/rewriting.py RefactoringIdiomsOutputdir/rewriting.py
--- codegen/rewriting.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/rewriting.py	2022-11-24 08:58:21.000000000 +0800
@@ -62,8 +62,7 @@
 
     """
     def __init__(self, cost_function=None, priority=1):
-        self.cost_function = cost_function
-        self.priority=priority
+        self.cost_function , self.priority  = cost_function, priority
 
     def cheapest(self, *args):
         return sorted(args, key=self.cost_function)[0]
@@ -103,8 +102,7 @@
 
     def __init__(self, query, value, **kwargs):
         super().__init__(**kwargs)
-        self.query = query
-        self.value = value
+        self.query , self.value  = query, value
 
     def __call__(self, expr):
         return expr.replace(self.query, self.value)
@@ -224,9 +222,7 @@
         weight = 10  # <-- this is an arbitrary number (heuristic)
         super().__init__(lambda e: e.is_Add, self.replace_in_Add,
                          cost_function=lambda expr: expr.count_ops() - weight*expr.count(func_m_1))
-        self.func = func
-        self.func_m_1 = func_m_1
-        self.opportunistic = opportunistic
+        self.func , self.func_m_1 , self.opportunistic  = func, func_m_1, opportunistic
 
     def _group_Add_terms(self, add):
         numbers, non_num = sift(add.args, lambda arg: arg.is_number, binary=True)
@@ -237,13 +233,13 @@
     def replace_in_Add(self, e):
         """ passed as second argument to Basic.replace(...) """
         numsum, terms_with_func, other_non_num_terms = self._group_Add_terms(e)
-        if numsum == 0:
+        if not numsum:
             return e
         substituted, untouched = [], []
         for with_func in terms_with_func:
             if with_func.is_Mul:
                 func, coeff = sift(with_func.args, lambda arg: arg.func == self.func, binary=True)
-                if len(func) == 1 and len(coeff) == 1:
+                if len(func) == 1 == len(coeff):
                     func, coeff = func[0], coeff[0]
                 else:
                     coeff = None
@@ -267,8 +263,7 @@
         return e.func(numsum, *substituted, *untouched, *other_non_num_terms)
 
     def __call__(self, expr):
-        alt1 = super().__call__(expr)
-        alt2 = super().__call__(expr.factor())
+        alt1 , alt2  = super().__call__(expr), super().__call__(expr.factor())
         return self.cheapest(alt1, alt2)
 
 
diff -uarN codegen/tests/test_algorithms.py RefactoringIdiomsOutputdir/tests/test_algorithms.py
--- codegen/tests/test_algorithms.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_algorithms.py	2022-11-24 08:58:23.000000000 +0800
@@ -72,8 +72,7 @@
     x = sp.Symbol('x', real=True)
     expr = sp.cos(x) - x**3
     func = newtons_method_function(expr, x)
-    py_mod = py_module(func)
-    namespace = {}
+    py_mod , namespace  = py_module(func), {}
     exec(py_mod, namespace, namespace)
     res = eval('newton(0.5)', namespace)
     assert abs(res - 0.865474033102) < 1e-12
diff -uarN codegen/tests/test_applications.py RefactoringIdiomsOutputdir/tests/test_applications.py
--- codegen/tests/test_applications.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_applications.py	2022-11-24 08:58:22.000000000 +0800
@@ -26,8 +26,7 @@
 
 
 def _render_compile_import(funcdef, build_dir):
-    code_str = render_as_source_file(funcdef, settings=dict(contract=False))
-    declar = ccode(FunctionPrototype.from_FunctionDefinition(funcdef))
+    code_str , declar  = render_as_source_file(funcdef, settings=dict(contract=False)), ccode(FunctionPrototype.from_FunctionDefinition(funcdef))
     return compile_link_import_strings([
         ('our_test_func.c', code_str),
         ('_our_test_func.pyx', ("#cython: language_level={}\n".format("3") +
diff -uarN codegen/tests/test_approximations.py RefactoringIdiomsOutputdir/tests/test_approximations.py
--- codegen/tests/test_approximations.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_approximations.py	2022-11-24 08:58:22.000000000 +0800
@@ -7,47 +7,34 @@
 
 def test_SumApprox_trivial():
     x = symbols('x')
-    expr1 = 1 + x
-    sum_approx = SumApprox(bounds={x: (-1e-20, 1e-20)}, reltol=1e-16)
+    expr1 , sum_approx  = 1 + x, SumApprox(bounds={x: (-1e-20, 1e-20)}, reltol=1e-16)
     apx1 = optimize(expr1, [sum_approx])
-    assert apx1 - 1 == 0
+    assert not apx1 - 1
 
 
 def test_SumApprox_monotone_terms():
     x, y, z = symbols('x y z')
-    expr1 = exp(z)*(x**2 + y**2 + 1)
-    bnds1 = {x: (0, 1e-3), y: (100, 1000)}
-    sum_approx_m2 = SumApprox(bounds=bnds1, reltol=1e-2)
-    sum_approx_m5 = SumApprox(bounds=bnds1, reltol=1e-5)
-    sum_approx_m11 = SumApprox(bounds=bnds1, reltol=1e-11)
-    assert (optimize(expr1, [sum_approx_m2])/exp(z) - (y**2)).simplify() == 0
-    assert (optimize(expr1, [sum_approx_m5])/exp(z) - (y**2 + 1)).simplify() == 0
-    assert (optimize(expr1, [sum_approx_m11])/exp(z) - (y**2 + 1 + x**2)).simplify() == 0
+    expr1 , bnds1  = exp(z) * (x ** 2 + y ** 2 + 1), {x: (0, 0.001), y: (100, 1000)}
+    sum_approx_m2 , sum_approx_m5 , sum_approx_m11  = SumApprox(bounds=bnds1, reltol=0.01), SumApprox(bounds=bnds1, reltol=1e-05), SumApprox(bounds=bnds1, reltol=1e-11)
+    assert not (optimize(expr1, [sum_approx_m2]) / exp(z) - y ** 2).simplify()
+    assert not (optimize(expr1, [sum_approx_m5]) / exp(z) - (y ** 2 + 1)).simplify()
+    assert not (optimize(expr1, [sum_approx_m11]) / exp(z) - (y ** 2 + 1 + x ** 2)).simplify()
 
 
 def test_SeriesApprox_trivial():
     x, z = symbols('x z')
     for factor in [1, exp(z)]:
         x = symbols('x')
-        expr1 = exp(x)*factor
-        bnds1 = {x: (-1, 1)}
-        series_approx_50 = SeriesApprox(bounds=bnds1, reltol=0.50)
-        series_approx_10 = SeriesApprox(bounds=bnds1, reltol=0.10)
-        series_approx_05 = SeriesApprox(bounds=bnds1, reltol=0.05)
-        c = (bnds1[x][1] + bnds1[x][0])/2  # 0.0
+        expr1 , bnds1  = exp(x) * factor, {x: (-1, 1)}
+        series_approx_50 , series_approx_10 , series_approx_05 , c  = SeriesApprox(bounds=bnds1, reltol=0.5), SeriesApprox(bounds=bnds1, reltol=0.1), SeriesApprox(bounds=bnds1, reltol=0.05), (bnds1[x][1] + bnds1[x][0]) / 2
         f0 = math.exp(c)  # 1.0
 
-        ref_50 = f0 + x + x**2/2
-        ref_10 = f0 + x + x**2/2 + x**3/6
-        ref_05 = f0 + x + x**2/2 + x**3/6 + x**4/24
-
-        res_50 = optimize(expr1, [series_approx_50])
-        res_10 = optimize(expr1, [series_approx_10])
-        res_05 = optimize(expr1, [series_approx_05])
-
-        assert (res_50/factor - ref_50).simplify() == 0
-        assert (res_10/factor - ref_10).simplify() == 0
-        assert (res_05/factor - ref_05).simplify() == 0
+        ref_50 , ref_10 , ref_05 , res_50 , res_10 , res_05  = f0 + x + x ** 2 / 2, f0 + x + x ** 2 / 2 + x ** 3 / 6, f0 + x + x ** 2 / 2 + x ** 3 / 6 + x ** 4 / 24, optimize(expr1, [series_approx_50]), optimize(expr1, [series_approx_10]), optimize(expr1, [series_approx_05])
+
+
+        assert not (res_50 / factor - ref_50).simplify()
+        assert not (res_10 / factor - ref_10).simplify()
+        assert not (res_05 / factor - ref_05).simplify()
 
         max_ord3 = SeriesApprox(bounds=bnds1, reltol=0.05, max_order=3)
         assert optimize(expr1, [max_ord3]) == expr1
diff -uarN codegen/tests/test_ast.py RefactoringIdiomsOutputdir/tests/test_ast.py
--- codegen/tests/test_ast.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_ast.py	2022-11-24 08:58:23.000000000 +0800
@@ -79,8 +79,7 @@
             ('/', DivAugmentedAssignment),
             ('%', ModAugmentedAssignment),
         ]:
-        a = aug_assign(x, binop, y)
-        b = cls(x, y)
+        a , b  = aug_assign(x, binop, y), cls(x, y)
         assert a.func(*a.args) == a == b
         assert a.binop == binop
         assert a.op == binop + '='
@@ -104,20 +103,7 @@
 
 
 def test_Assignment_printing():
-    assignment_classes = [
-        Assignment,
-        AddAugmentedAssignment,
-        SubAugmentedAssignment,
-        MulAugmentedAssignment,
-        DivAugmentedAssignment,
-        ModAugmentedAssignment,
-    ]
-    pairs = [
-        (x, 2 * y + 2),
-        (B[i], x),
-        (A22, B22),
-        (A[0, 0], x),
-    ]
+    assignment_classes , pairs  = [Assignment, AddAugmentedAssignment, SubAugmentedAssignment, MulAugmentedAssignment, DivAugmentedAssignment, ModAugmentedAssignment], [(x, 2 * y + 2), (B[i], x), (A22, B22), (A[0, 0], x)]
 
     for cls in assignment_classes:
         for lhs, rhs in pairs:
@@ -140,14 +126,7 @@
         Assignment(y, 2),
         ]
 
-    ordered_assignments = [
-        # Note that the unrelated z=1 and y=2 are kept in that order
-        Assignment(z, 1),
-        Assignment(y, 2),
-        Assignment(x, y + z),
-        Assignment(t, x),
-        ]
-    c1 = CodeBlock.topological_sort(assignments)
+    ordered_assignments , c1  = [Assignment(z, 1), Assignment(y, 2), Assignment(x, y + z), Assignment(t, x)], CodeBlock.topological_sort(assignments)
     assert c1 == CodeBlock(*ordered_assignments)
 
     # Cycle
@@ -168,14 +147,8 @@
         Assignment(y, b + 3),
         ]
 
-    free_assignments_ordered = [
-        Assignment(z, a * b),
-        Assignment(y, b + 3),
-        Assignment(x, y + z),
-        Assignment(t, x),
-        ]
+    free_assignments_ordered , c2  = [Assignment(z, a * b), Assignment(y, b + 3), Assignment(x, y + z), Assignment(t, x)], CodeBlock.topological_sort(free_assignments)
 
-    c2 = CodeBlock.topological_sort(free_assignments)
     assert c2 == CodeBlock(*free_assignments_ordered)
 
 def test_CodeBlock_free_symbols():
@@ -185,7 +158,7 @@
         Assignment(t, x),
         Assignment(y, 2),
         )
-    assert c1.free_symbols == set()
+    assert not c1.free_symbols
 
     c2 = CodeBlock(
         Assignment(x, y + z),
@@ -256,7 +229,7 @@
         pass
     foo = Foo()
     assert foo != none
-    assert none == None
+    assert not none
     assert none == NoneToken()
     assert none.func(*none.args) == none
 
@@ -299,8 +272,7 @@
     assert repr(t) == "Type(String('MyType'))"
     assert Type(t) == t
     assert t.func(*t.args) == t
-    t1 = Type('t1')
-    t2 = Type('t2')
+    t1 , t2  = Type('t1'), Type('t2')
     assert t1 != t2
     assert t1 == t1 and t2 == t2
     t1b = Type('t1')
@@ -332,7 +304,7 @@
     assert int8.cast_check(-128) == -128
     raises(ValueError, lambda: int8.cast_check(-129))
 
-    assert uint8.cast_check(0) == 0
+    assert not uint8.cast_check(0)
     assert uint8.cast_check(128) == 128
     raises(ValueError, lambda: uint8.cast_check(256.0))
     raises(ValueError, lambda: uint8.cast_check(-1))
@@ -340,8 +312,7 @@
 def test_Attribute():
     noexcept = Attribute('noexcept')
     assert noexcept == Attribute('noexcept')
-    alignas16 = Attribute('alignas', [16])
-    alignas32 = Attribute('alignas', [32])
+    alignas16 , alignas32  = Attribute('alignas', [16]), Attribute('alignas', [32])
     assert alignas16 != alignas32
     assert alignas16.func(*alignas16.args) == alignas16
 
@@ -555,10 +526,8 @@
 
 
 def test_Scope():
-    assign = Assignment(x, y)
-    incr = AddAugmentedAssignment(x, 1)
-    scp = Scope([assign, incr])
-    cblk = CodeBlock(assign, incr)
+    assign , incr  = Assignment(x, y), AddAugmentedAssignment(x, 1)
+    scp , cblk  = Scope([assign, incr]), CodeBlock(assign, incr)
     assert scp.body == cblk
     assert scp == Scope(cblk)
     assert scp != Scope([incr, assign])
@@ -578,12 +547,11 @@
     ps2 = Print([n, x])
     assert ps2 == Print([n, x])
     assert ps2 != ps
-    assert ps2.format_string == None
+    assert not ps2.format_string
 
 
 def test_FunctionPrototype_and_FunctionDefinition():
-    vx = Variable(x, type=real)
-    vn = Variable(n, type=integer)
+    vx , vn  = Variable(x, type=real), Variable(n, type=integer)
     fp1 = FunctionPrototype(real, 'power', [vx, vn])
     assert fp1.return_type == real
     assert fp1.name == String('power')
@@ -640,13 +608,10 @@
     )
 
 def test_ast_replace():
-    x = Variable('x', real)
-    y = Variable('y', real)
-    n = Variable('n', integer)
+    x , y , n  = Variable('x', real), Variable('y', real), Variable('n', integer)
 
     pwer = FunctionDefinition(real, 'pwer', [x, n], [pow(x.symbol, n.symbol)])
-    pname = pwer.name
-    pcall = FunctionCall('pwer', [y, 3])
+    pname , pcall  = pwer.name, FunctionCall('pwer', [y, 3])
 
     tree1 = CodeBlock(pwer, pcall)
     assert str(tree1.args[0].name) == 'pwer'
diff -uarN codegen/tests/test_cfunctions.py RefactoringIdiomsOutputdir/tests/test_cfunctions.py
--- codegen/tests/test_cfunctions.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_cfunctions.py	2022-11-24 08:58:22.000000000 +0800
@@ -10,7 +10,7 @@
 
 def test_expm1():
     # Eval
-    assert expm1(0) == 0
+    assert not expm1(0)
 
     x = Symbol('x', real=True)
 
@@ -28,22 +28,22 @@
     assert expm1(x).is_finite
 
     # Diff
-    assert expm1(42*x).diff(x) - 42*exp(42*x) == 0
-    assert expm1(42*x).diff(x) - expm1(42*x).expand(func=True).diff(x) == 0
+    assert not expm1(42 * x).diff(x) - 42 * exp(42 * x)
+    assert not expm1(42 * x).diff(x) - expm1(42 * x).expand(func=True).diff(x)
 
 
 def test_log1p():
     # Eval
-    assert log1p(0) == 0
+    assert not log1p(0)
     d = S(10)
-    assert expand_log(log1p(d**-1000) - log(d**1000 + 1) + log(d**1000)) == 0
+    assert not expand_log(log1p(d ** (-1000)) - log(d ** 1000 + 1) + log(d ** 1000))
 
     x = Symbol('x', real=True)
 
     # Expand and rewrite
-    assert log1p(x).expand(func=True) - log(x + 1) == 0
-    assert log1p(x).rewrite('tractable') - log(x + 1) == 0
-    assert log1p(x).rewrite('log') - log(x + 1) == 0
+    assert not log1p(x).expand(func=True) - log(x + 1)
+    assert not log1p(x).rewrite('tractable') - log(x + 1)
+    assert not log1p(x).rewrite('log') - log(x + 1)
 
     # Precision
     assert not abs(log(1e-99 + 1).evalf() - 1e-99) < 1e-100  # for comparison
@@ -65,8 +65,8 @@
     assert log1p(Symbol('o', nonnegative=True)).is_nonnegative
 
     # Diff
-    assert log1p(42*x).diff(x) - 42/(42*x + 1) == 0
-    assert log1p(42*x).diff(x) - log1p(42*x).expand(func=True).diff(x) == 0
+    assert not log1p(42 * x).diff(x) - 42 / (42 * x + 1)
+    assert not log1p(42 * x).diff(x) - log1p(42 * x).expand(func=True).diff(x)
 
 
 def test_exp2():
@@ -76,11 +76,11 @@
     x = Symbol('x', real=True)
 
     # Expand
-    assert exp2(x).expand(func=True) - 2**x == 0
+    assert not exp2(x).expand(func=True) - 2 ** x
 
     # Diff
-    assert exp2(42*x).diff(x) - 42*exp2(42*x)*log(2) == 0
-    assert exp2(42*x).diff(x) - exp2(42*x).diff(x) == 0
+    assert not exp2(42 * x).diff(x) - 42 * exp2(42 * x) * log(2)
+    assert not exp2(42 * x).diff(x) - exp2(42 * x).diff(x)
 
 
 def test_log2():
@@ -93,73 +93,73 @@
     assert log2(2**x) == x
 
     # Expand
-    assert log2(x).expand(func=True) - log(x)/log(2) == 0
+    assert not log2(x).expand(func=True) - log(x) / log(2)
 
     # Diff
-    assert log2(42*x).diff() - 1/(log(2)*x) == 0
-    assert log2(42*x).diff() - log2(42*x).expand(func=True).diff(x) == 0
+    assert not log2(42 * x).diff() - 1 / (log(2) * x)
+    assert not log2(42 * x).diff() - log2(42 * x).expand(func=True).diff(x)
 
 
 def test_fma():
     x, y, z = symbols('x y z')
 
     # Expand
-    assert fma(x, y, z).expand(func=True) - x*y - z == 0
+    assert not fma(x, y, z).expand(func=True) - x * y - z
 
     expr = fma(17*x, 42*y, 101*z)
 
     # Diff
-    assert expr.diff(x) - expr.expand(func=True).diff(x) == 0
-    assert expr.diff(y) - expr.expand(func=True).diff(y) == 0
-    assert expr.diff(z) - expr.expand(func=True).diff(z) == 0
-
-    assert expr.diff(x) - 17*42*y == 0
-    assert expr.diff(y) - 17*42*x == 0
-    assert expr.diff(z) - 101 == 0
+    assert not expr.diff(x) - expr.expand(func=True).diff(x)
+    assert not expr.diff(y) - expr.expand(func=True).diff(y)
+    assert not expr.diff(z) - expr.expand(func=True).diff(z)
+
+    assert not expr.diff(x) - 17 * 42 * y
+    assert not expr.diff(y) - 17 * 42 * x
+    assert not expr.diff(z) - 101
 
 
 def test_log10():
     x = Symbol('x')
 
     # Expand
-    assert log10(x).expand(func=True) - log(x)/log(10) == 0
+    assert not log10(x).expand(func=True) - log(x) / log(10)
 
     # Diff
-    assert log10(42*x).diff(x) - 1/(log(10)*x) == 0
-    assert log10(42*x).diff(x) - log10(42*x).expand(func=True).diff(x) == 0
+    assert not log10(42 * x).diff(x) - 1 / (log(10) * x)
+    assert not log10(42 * x).diff(x) - log10(42 * x).expand(func=True).diff(x)
 
 
 def test_Cbrt():
     x = Symbol('x')
 
     # Expand
-    assert Cbrt(x).expand(func=True) - x**Rational(1, 3) == 0
+    assert not Cbrt(x).expand(func=True) - x ** Rational(1, 3)
 
     # Diff
-    assert Cbrt(42*x).diff(x) - 42*(42*x)**(Rational(1, 3) - 1)/3 == 0
-    assert Cbrt(42*x).diff(x) - Cbrt(42*x).expand(func=True).diff(x) == 0
+    assert not Cbrt(42 * x).diff(x) - 42 * (42 * x) ** (Rational(1, 3) - 1) / 3
+    assert not Cbrt(42 * x).diff(x) - Cbrt(42 * x).expand(func=True).diff(x)
 
 
 def test_Sqrt():
     x = Symbol('x')
 
     # Expand
-    assert Sqrt(x).expand(func=True) - x**S.Half == 0
+    assert not Sqrt(x).expand(func=True) - x ** S.Half
 
     # Diff
-    assert Sqrt(42*x).diff(x) - 42*(42*x)**(S.Half - 1)/2 == 0
-    assert Sqrt(42*x).diff(x) - Sqrt(42*x).expand(func=True).diff(x) == 0
+    assert not Sqrt(42 * x).diff(x) - 42 * (42 * x) ** (S.Half - 1) / 2
+    assert not Sqrt(42 * x).diff(x) - Sqrt(42 * x).expand(func=True).diff(x)
 
 
 def test_hypot():
     x, y = symbols('x y')
 
     # Expand
-    assert hypot(x, y).expand(func=True) - (x**2 + y**2)**S.Half == 0
+    assert not hypot(x, y).expand(func=True) - (x ** 2 + y ** 2) ** S.Half
 
     # Diff
-    assert hypot(17*x, 42*y).diff(x).expand(func=True) - hypot(17*x, 42*y).expand(func=True).diff(x) == 0
-    assert hypot(17*x, 42*y).diff(y).expand(func=True) - hypot(17*x, 42*y).expand(func=True).diff(y) == 0
+    assert not hypot(17 * x, 42 * y).diff(x).expand(func=True) - hypot(17 * x, 42 * y).expand(func=True).diff(x)
+    assert not hypot(17 * x, 42 * y).diff(y).expand(func=True) - hypot(17 * x, 42 * y).expand(func=True).diff(y)
 
-    assert hypot(17*x, 42*y).diff(x).expand(func=True) - 2*17*17*x*((17*x)**2 + (42*y)**2)**Rational(-1, 2)/2 == 0
-    assert hypot(17*x, 42*y).diff(y).expand(func=True) - 2*42*42*y*((17*x)**2 + (42*y)**2)**Rational(-1, 2)/2 == 0
+    assert not hypot(17 * x, 42 * y).diff(x).expand(func=True) - 2 * 17 * 17 * x * ((17 * x) ** 2 + (42 * y) ** 2) ** Rational(-1, 2) / 2
+    assert not hypot(17 * x, 42 * y).diff(y).expand(func=True) - 2 * 42 * 42 * y * ((17 * x) ** 2 + (42 * y) ** 2) ** Rational(-1, 2) / 2
diff -uarN codegen/tests/test_fnodes.py RefactoringIdiomsOutputdir/tests/test_fnodes.py
--- codegen/tests/test_fnodes.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_fnodes.py	2022-11-24 08:58:22.000000000 +0800
@@ -33,8 +33,7 @@
     if not has_fortran():
         skip("No fortran compiler found.")
     a = Symbol('a', real=True)
-    body = [Return((sum_(a**2)/size(a))**.5)]
-    arr = array(a, dim=[':'], intent='in')
+    body , arr  = [Return((sum_(a ** 2) / size(a)) ** 0.5)], array(a, dim=[':'], intent='in')
     fd = FunctionDefinition(real, 'rms', [arr], body)
     render_as_module([fd], 'mod_rms')
 
@@ -61,8 +60,7 @@
 
     a, i = symbols('a i', integer=True)
     idl = ImpliedDoLoop(i**3, i, -3, 3, 2)
-    ac = ArrayConstructor([-28, idl, 28])
-    a = array(a, dim=[':'], attrs=[allocatable])
+    ac , a  = ArrayConstructor([-28, idl, 28]), array(a, dim=[':'], attrs=[allocatable])
     prog = Program('idlprog', [
         a.as_Declaration(),
         Assignment(a, ac),
@@ -80,8 +78,7 @@
 def test_Program():
     x = Symbol('x', real=True)
     vx = Variable.deduced(x, 42)
-    decl = Declaration(vx)
-    prnt = Print([x, x+1])
+    decl , prnt  = Declaration(vx), Print([x, x + 1])
     prog = Program('foo', [decl, prnt])
     if not has_fortran():
         skip("No fortran compiler found.")
@@ -98,8 +95,7 @@
     x = Symbol('x', real=True)
     v_x = Variable.deduced(x)
     sq = FunctionDefinition(real, 'sqr', [v_x], [Return(x**2)])
-    mod_sq = Module('mod_sq', [], [sq])
-    sq_call = FunctionCall('sqr', [42.])
+    mod_sq , sq_call  = Module('mod_sq', [], [sq]), FunctionCall('sqr', [42.0])
     prg_sq = Program('foobar', [
         use('mod_sq', only=['sqr']),
         Print(['"Square of 42 = "', sq_call])
@@ -122,21 +118,12 @@
     # http://www.fortran90.org/src/best-practices.html#arrays
     r = Symbol('r', real=True)
     i = Symbol('i', integer=True)
-    v_r = Variable.deduced(r, attrs=(dimension(assumed_extent), intent_out))
-    v_i = Variable.deduced(i)
-    v_n = Variable('n', integer)
+    v_r , v_i , v_n  = Variable.deduced(r, attrs=(dimension(assumed_extent), intent_out)), Variable.deduced(i), Variable('n', integer)
     do_loop = Do([
         Assignment(Element(r, [i]), literal_dp(1)/i**2)
     ], i, 1, v_n)
-    sub = Subroutine("f", [v_r], [
-        Declaration(v_n),
-        Declaration(v_i),
-        Assignment(v_n, size(r)),
-        do_loop
-    ])
-    x = Symbol('x', real=True)
-    v_x3 = Variable.deduced(x, attrs=[dimension(3)])
-    mod = Module('mymod', definitions=[sub])
+    sub , x  = Subroutine('f', [v_r], [Declaration(v_n), Declaration(v_i), Assignment(v_n, size(r)), do_loop]), Symbol('x', real=True)
+    v_x3 , mod  = Variable.deduced(x, attrs=[dimension(3)]), Module('mymod', definitions=[sub])
     prog = Program('foo', [
         use(mod, only=[sub]),
         Declaration(v_x3),
@@ -193,10 +180,8 @@
     if not np:
         skip("NumPy not found.")
 
-    a = Symbol('a', real=True)
-    s = Symbol('s', integer=True)
-    body = [Return((sum_(a**2)/s)**.5)]
-    arr = array(a, dim=[s], intent='in')
+    a , s  = Symbol('a', real=True), Symbol('s', integer=True)
+    body , arr  = [Return((sum_(a ** 2) / s) ** 0.5)], array(a, dim=[s], intent='in')
     fd = FunctionDefinition(real, 'rms', [arr, s], body, attrs=[bind_C('rms')])
     f_mod = render_as_module([fd], 'mod_rms')
 
diff -uarN codegen/tests/test_numpy_nodes.py RefactoringIdiomsOutputdir/tests/test_numpy_nodes.py
--- codegen/tests/test_numpy_nodes.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_numpy_nodes.py	2022-11-24 08:58:22.000000000 +0800
@@ -8,18 +8,13 @@
 x, y, z = symbols('x y z')
 
 def test_logaddexp():
-    lae_xy = logaddexp(x, y)
-    ref_xy = log(exp(x) + exp(y))
+    lae_xy , ref_xy  = logaddexp(x, y), log(exp(x) + exp(y))
     for wrt, deriv_order in product([x, y, z], range(3)):
-        assert (
-            lae_xy.diff(wrt, deriv_order) -
-            ref_xy.diff(wrt, deriv_order)
-        ).rewrite(log).simplify() == 0
+        assert not (lae_xy.diff(wrt, deriv_order) - ref_xy.diff(wrt, deriv_order)).rewrite(log).simplify()
 
     one_third_e = 1*exp(1)/3
     two_thirds_e = 2*exp(1)/3
-    logThirdE = log(one_third_e)
-    logTwoThirdsE = log(two_thirds_e)
+    logThirdE , logTwoThirdsE  = log(one_third_e), log(two_thirds_e)
     lae_sum_to_e = logaddexp(logThirdE, logTwoThirdsE)
     assert lae_sum_to_e.rewrite(log) == 1
     assert lae_sum_to_e.simplify() == 1
@@ -28,21 +23,16 @@
 
 
 def test_logaddexp2():
-    lae2_xy = logaddexp2(x, y)
-    ref2_xy = log(2**x + 2**y)/log(2)
+    lae2_xy , ref2_xy  = logaddexp2(x, y), log(2 ** x + 2 ** y) / log(2)
     for wrt, deriv_order in product([x, y, z], range(3)):
-        assert (
-            lae2_xy.diff(wrt, deriv_order) -
-            ref2_xy.diff(wrt, deriv_order)
-        ).rewrite(log).cancel() == 0
+        assert not (lae2_xy.diff(wrt, deriv_order) - ref2_xy.diff(wrt, deriv_order)).rewrite(log).cancel()
 
     def lb(x):
         return log(x)/log(2)
 
     two_thirds = S.One*2/3
     four_thirds = 2*two_thirds
-    lbTwoThirds = lb(two_thirds)
-    lbFourThirds = lb(four_thirds)
+    lbTwoThirds , lbFourThirds  = lb(two_thirds), lb(four_thirds)
     lae2_sum_to_2 = logaddexp2(lbTwoThirds, lbFourThirds)
     assert lae2_sum_to_2.rewrite(log) == 1
     assert lae2_sum_to_2.simplify() == 1
diff -uarN codegen/tests/test_rewriting.py RefactoringIdiomsOutputdir/tests/test_rewriting.py
--- codegen/tests/test_rewriting.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_rewriting.py	2022-11-24 08:58:22.000000000 +0800
@@ -74,7 +74,7 @@
 
     expr1 = exp(x) - 1
     opt1 = optimize(expr1, [expm1_opt])
-    assert expm1(x) - opt1 == 0
+    assert not expm1(x) - opt1
     assert opt1.rewrite(exp) == expr1
 
     expr2 = 3*exp(x) - 3
@@ -113,24 +113,20 @@
     expr7 = (2*exp(x) - 1)/(1 - exp(y)) - 1/(1-exp(y))
     opt7 = optimize(expr7, [expm1_opt])
     assert -2*expm1(x)/expm1(y) == opt7
-    assert (opt7.rewrite(exp) - expr7).factor() == 0
+    assert not (opt7.rewrite(exp) - expr7).factor()
 
     expr8 = (1+exp(x))**2 - 4
-    opt8 = optimize(expr8, [expm1_opt])
-    tgt8a = (exp(x) + 3)*expm1(x)
-    tgt8b = 2*expm1(x) + expm1(2*x)
+    opt8 , tgt8a , tgt8b  = optimize(expr8, [expm1_opt]), (exp(x) + 3) * expm1(x), 2 * expm1(x) + expm1(2 * x)
     # Both tgt8a & tgt8b seem to give full precision (~16 digits for double)
     # for x=1e-7 (compare with expr8 which only achieves ~8 significant digits).
     # If we can show that either tgt8a or tgt8b is preferable, we can
     # change this test to ensure the preferable version is returned.
-    assert (tgt8a - tgt8b).rewrite(exp).factor() == 0
+    assert not (tgt8a - tgt8b).rewrite(exp).factor()
     assert opt8 in (tgt8a, tgt8b)
-    assert (opt8.rewrite(exp) - expr8).factor() == 0
+    assert not (opt8.rewrite(exp) - expr8).factor()
 
     expr9 = sin(expr8)
-    opt9 = optimize(expr9, [expm1_opt])
-    tgt9a = sin(tgt8a)
-    tgt9b = sin(tgt8b)
+    opt9 , tgt9a , tgt9b  = optimize(expr9, [expm1_opt]), sin(tgt8a), sin(tgt8b)
     assert opt9 in (tgt9a, tgt9b)
     assert (opt9.rewrite(exp) - expr9.rewrite(exp)).factor().is_zero
 
@@ -147,7 +143,7 @@
 
     expr1 = cos(x) - 1
     opt1 = optimize(expr1, [cosm1_opt])
-    assert cosm1(x) - opt1 == 0
+    assert not cosm1(x) - opt1
     assert opt1.rewrite(cos) == expr1
 
     expr2 = 3*cos(x) - 3
@@ -198,17 +194,17 @@
     x = Symbol('x')
     expr1 = log(x + 1)
     opt1 = optimize(expr1, [log1p_opt])
-    assert log1p(x) - opt1 == 0
+    assert not log1p(x) - opt1
     assert opt1.rewrite(log) == expr1
 
     expr2 = log(3*x + 3)
     opt2 = optimize(expr2, [log1p_opt])
     assert log1p(x) + log(3) == opt2
-    assert (opt2.rewrite(log) - expr2).simplify() == 0
+    assert not (opt2.rewrite(log) - expr2).simplify()
 
     expr3 = log(2*x + 1)
     opt3 = optimize(expr3, [log1p_opt])
-    assert log1p(2*x) - opt3 == 0
+    assert not log1p(2 * x) - opt3
     assert opt3.rewrite(log) == expr3
 
     expr4 = log(x+3)
@@ -232,19 +228,19 @@
     expr3 = log(x)/log(2) + log(17*x + 17)
     opt3 = optimize(expr3, optims_c99)
     delta3 = opt3 - (log2(x) + log(17) + log1p(x))
-    assert delta3 == 0
-    assert (opt3.rewrite(log) - expr3).simplify() == 0
+    assert not delta3
+    assert not (opt3.rewrite(log) - expr3).simplify()
 
     expr4 = 2**x + 3*log(5*x + 7)/(13*log(2)) + 11*exp(x) - 11 + log(17*x + 17)
     opt4 = optimize(expr4, optims_c99).simplify()
     delta4 = opt4 - (exp2(x) + 3*log2(5*x + 7)/13 + 11*expm1(x) + log(17) + log1p(x))
-    assert delta4 == 0
-    assert (opt4.rewrite(exp).rewrite(log).rewrite(Pow) - expr4).simplify() == 0
+    assert not delta4
+    assert not (opt4.rewrite(exp).rewrite(log).rewrite(Pow) - expr4).simplify()
 
     expr5 = 3*exp(2*x) - 3
     opt5 = optimize(expr5, optims_c99)
     delta5 = opt5 - 3*expm1(2*x)
-    assert delta5 == 0
+    assert not delta5
     assert opt5.rewrite(exp) == expr5
 
     expr6 = exp(2*x) - 3
@@ -254,8 +250,8 @@
     expr7 = log(3*x + 3)
     opt7 = optimize(expr7, optims_c99)
     delta7 = opt7 - (log(3) + log1p(x))
-    assert delta7 == 0
-    assert (opt7.rewrite(log) - expr7).simplify() == 0
+    assert not delta7
+    assert not (opt7.rewrite(log) - expr7).simplify()
 
     expr8 = log(2*x + 3)
     opt8 = optimize(expr8, optims_c99)
@@ -263,9 +259,7 @@
 
 
 def test_create_expand_pow_optimization():
-    cc = lambda x: ccode(
-        optimize(x, [create_expand_pow_optimization(4)]))
-    x = Symbol('x')
+    cc , x  = lambda x: ccode(optimize(x, [create_expand_pow_optimization(4)])), Symbol('x')
     assert cc(x**4) == 'x*x*x*x'
     assert cc(x**4 + x**2) == 'x*x + x*x*x*x'
     assert cc(x**5 + x**4) == 'pow(x, 5) + x*x*x*x'
@@ -288,8 +282,7 @@
 
 def test_matsolve():
     n = Symbol('n', integer=True)
-    A = MatrixSymbol('A', n, n)
-    x = MatrixSymbol('x', n, 1)
+    A , x  = MatrixSymbol('A', n, n), MatrixSymbol('x', n, 1)
 
     with assuming(Q.fullrank(A)):
         assert optimize(A**(-1) * x, [matinv_opt]) == MatrixSolve(A, x)
@@ -300,8 +293,8 @@
     x, y = map(Symbol, 'x y'.split())
     expr1 = log(exp(x) + exp(y))
     opt1 = optimize(expr1, [logaddexp_opt])
-    assert logaddexp(x, y) - opt1 == 0
-    assert logaddexp(y, x) - opt1 == 0
+    assert not logaddexp(x, y) - opt1
+    assert not logaddexp(y, x) - opt1
     assert opt1.rewrite(log) == expr1
 
 
@@ -309,8 +302,8 @@
     x, y = map(Symbol, 'x y'.split())
     expr1 = log(2**x + 2**y)/log(2)
     opt1 = optimize(expr1, [logaddexp2_opt])
-    assert logaddexp2(x, y) - opt1 == 0
-    assert logaddexp2(y, x) - opt1 == 0
+    assert not logaddexp2(x, y) - opt1
+    assert not logaddexp2(y, x) - opt1
     assert opt1.rewrite(log) == expr1
 
 
@@ -369,49 +362,25 @@
     if not has_c():
         skip("No C compiler found.")
 
-    x = Symbol('x')
-    about_two = 2**(58/S(117))*3**(97/S(117))*5**(4/S(39))*7**(92/S(117))/S(30)*pi
+    x , about_two  = Symbol('x'), 2 ** (58 / S(117)) * 3 ** (97 / S(117)) * 5 ** (4 / S(39)) * 7 ** (92 / S(117)) / S(30) * pi
     # about_two: 1.999999999999581826
-    unchanged = 2*exp(x) - about_two
-    xval = S(10)**-11
-    ref = unchanged.subs(x, xval).n(19) # 2.0418173913673213e-11
+    unchanged , xval  = 2 * exp(x) - about_two, S(10) ** (-11)
+    ref , rewritten , NUMBER_OF_DIGITS  = unchanged.subs(x, xval).n(19), optimize(2 * exp(x) - about_two, [expm1_opt]), 25 # 2.0418173913673213e-11
 
-    rewritten = optimize(2*exp(x) - about_two, [expm1_opt])
 
     # Unfortunately, we need to call ``.n()`` on our expressions before we hand them
     # to ``ccode``, and we need to request a large number of significant digits.
     # In this test, results converged for double precision when the following number
     # of significant digits were chosen:
-    NUMBER_OF_DIGITS = 25   # TODO: this should ideally be automatically handled.
 
-    func_c = '''
-#include <math.h>
+    func_c , func_pyx  = '\n#include <math.h>\n\ndouble func_unchanged(double x) {\n    return %(unchanged)s;\n}\ndouble func_rewritten(double x) {\n    return %(rewritten)s;\n}\n' % dict(unchanged=ccode(unchanged.n(NUMBER_OF_DIGITS)), rewritten=ccode(rewritten.n(NUMBER_OF_DIGITS))), '\n#cython: language_level=3\ncdef extern double func_unchanged(double)\ncdef extern double func_rewritten(double)\ndef py_unchanged(x):\n    return func_unchanged(x)\ndef py_rewritten(x):\n    return func_rewritten(x)\n'
 
-double func_unchanged(double x) {
-    return %(unchanged)s;
-}
-double func_rewritten(double x) {
-    return %(rewritten)s;
-}
-''' % dict(unchanged=ccode(unchanged.n(NUMBER_OF_DIGITS)),
-           rewritten=ccode(rewritten.n(NUMBER_OF_DIGITS)))
-
-    func_pyx = '''
-#cython: language_level=3
-cdef extern double func_unchanged(double)
-cdef extern double func_rewritten(double)
-def py_unchanged(x):
-    return func_unchanged(x)
-def py_rewritten(x):
-    return func_rewritten(x)
-'''
     with tempfile.TemporaryDirectory() as folder:
         mod, info = compile_link_import_strings(
             [('func.c', func_c), ('_func.pyx', func_pyx)],
             build_dir=folder, compile_kwargs=dict(std='c99')
         )
-        err_rewritten = abs(mod.py_rewritten(1e-11) - ref)
-        err_unchanged = abs(mod.py_unchanged(1e-11) - ref)
+        err_rewritten , err_unchanged  = abs(mod.py_rewritten(1e-11) - ref), abs(mod.py_unchanged(1e-11) - ref)
         assert 1e-27 < err_rewritten < 1e-25  # highly accurate.
         assert 1e-19 < err_unchanged < 1e-16  # quite poor.
 
diff -uarN codegen/tests/test_scipy_nodes.py RefactoringIdiomsOutputdir/tests/test_scipy_nodes.py
--- codegen/tests/test_scipy_nodes.py	2022-10-17 16:26:03.000000000 +0800
+++ RefactoringIdiomsOutputdir/tests/test_scipy_nodes.py	2022-11-24 08:58:22.000000000 +0800
@@ -8,13 +8,9 @@
 
 
 def test_cosm1():
-    cm1_xy = cosm1(x*y)
-    ref_xy = cos(x*y) - 1
+    cm1_xy , ref_xy  = cosm1(x * y), cos(x * y) - 1
     for wrt, deriv_order in product([x, y, z], range(3)):
-        assert (
-            cm1_xy.diff(wrt, deriv_order) -
-            ref_xy.diff(wrt, deriv_order)
-        ).rewrite(cos).simplify() == 0
+        assert not (cm1_xy.diff(wrt, deriv_order) - ref_xy.diff(wrt, deriv_order)).rewrite(cos).simplify()
 
     expr_minus2 = cosm1(pi)
     assert expr_minus2.rewrite(cos) == -2
